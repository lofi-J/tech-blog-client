---
title: "TypeScript 고급 패턴 완벽 가이드: 제네릭, 유니온 타입, 조건부 타입까지"
thumbnail: "/mdx-images/typescript/advanced-patterns.png"
slug: "typescript-advanced-patterns"
description: >
  TypeScript의 고급 기능들을 활용한 실전 패턴들을 알아봅니다. 
  제네릭, 유니온 타입, 조건부 타입, 매핑 타입 등 복잡한 타입 시스템을 
  마스터하여 더 안전하고 유연한 코드를 작성해보세요.
category: "TypeScript"
tags: ["TypeScript", "Advanced", "Type System", "Generics"]
published: "2025-01-25"
---

TypeScript의 강력한 타입 시스템을 활용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 이 글에서는 실전에서 유용한 고급 TypeScript 패턴들을 알아보겠습니다.

## 제네릭을 활용한 재사용 가능한 타입

제네릭은 타입을 매개변수화하여 다양한 타입에서 재사용할 수 있게 해줍니다.

```typescript
// 기본적인 제네릭 함수
function identity<T>(arg: T): T {
  return arg;
}

// 제네릭 인터페이스
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 제네릭 클래스
class DataContainer<T> {
  private data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  get(index: number): T | undefined {
    return this.data[index];
  }

  getAll(): T[] {
    return [...this.data];
  }
}

// 사용 예시
const numberContainer = new DataContainer<number>();
numberContainer.add(1);
numberContainer.add(2);

const stringContainer = new DataContainer<string>();
stringContainer.add("hello");
stringContainer.add("world");
```

## 유니온 타입과 리터럴 타입

유니온 타입을 활용하여 더 정확한 타입 정의를 만들 수 있습니다.

```typescript
// 리터럴 타입과 유니온 타입
type Status = "loading" | "success" | "error";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

// 유니온 타입을 활용한 함수 오버로딩
function processData(data: string): string;
function processData(data: number): number;
function processData(data: boolean): boolean;
function processData(
  data: string | number | boolean
): string | number | boolean {
  if (typeof data === "string") {
    return data.toUpperCase();
  } else if (typeof data === "number") {
    return data * 2;
  } else {
    return !data;
  }
}

// 유니온 타입을 활용한 상태 관리
interface LoadingState {
  status: "loading";
}

interface SuccessState<T> {
  status: "success";
  data: T;
}

interface ErrorState {
  status: "error";
  error: string;
}

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

function handleAsyncState<T>(state: AsyncState<T>): string {
  switch (state.status) {
    case "loading":
      return "로딩 중...";
    case "success":
      return `데이터: ${JSON.stringify(state.data)}`;
    case "error":
      return `에러: ${state.error}`;
  }
}
```

## 조건부 타입과 매핑 타입

조건부 타입을 사용하여 타입을 동적으로 변환할 수 있습니다.

```typescript
// 조건부 타입
type NonNullable<T> = T extends null | undefined ? never : T;
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

// 매핑 타입
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};

type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 실전 예시: API 응답 타입 변환
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// 선택적 필드로 변환
type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string; age?: number; }

// 읽기 전용으로 변환
type ReadonlyUser = Readonly<User>;
// { readonly id: number; readonly name: string; readonly email: string; readonly age: number; }

// 특정 필드만 선택
type PickUser = Pick<User, "name" | "email">;
// { name: string; email: string; }

// 특정 필드 제외
type OmitUser = Omit<User, "id">;
// { name: string; email: string; age: number; }
```

## 고급 유틸리티 타입

복잡한 타입 변환을 위한 고급 유틴리티 타입들을 만들어보겠습니다.

```typescript
// 함수의 매개변수 타입 추출
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// 함수의 반환 타입 추출
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

// 프로미스의 타입 추출
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

// 중첩된 프로미스 타입 추출
type DeepUnwrapPromise<T> =
  T extends Promise<infer U> ? DeepUnwrapPromise<U> : T;

// 객체의 모든 프로퍼티를 함수로 변환
type Functionify<T> = {
  [P in keyof T]: T[P] extends Function ? T[P] : () => T[P];
};

// 실전 예시
interface Config {
  apiUrl: string;
  timeout: number;
  retries: number;
}

type ConfigFunctions = Functionify<Config>;
// {
//   apiUrl: () => string;
//   timeout: () => number;
//   retries: () => number;
// }

// 조건부 타입을 활용한 타입 가드
type IsString<T> = T extends string ? true : false;
type IsNumber<T> = T extends number ? true : false;

// 타입 안전한 이벤트 핸들러
type EventHandler<T extends Event> = (event: T) => void;

interface CustomEvent {
  type: "custom";
  data: any;
}

type CustomEventHandler = EventHandler<CustomEvent>;
```

## 마무리

TypeScript의 고급 패턴들을 활용하면 타입 안전성을 높이면서도 유연한 코드를 작성할 수 있습니다. 이 글에서 소개한 패턴들을 실전 프로젝트에 적용하여 더 견고한 타입 시스템을 구축해보세요. 다음 글에서는 더 복잡한 타입 패턴과 실전 활용 사례에 대해 알아보겠습니다.
