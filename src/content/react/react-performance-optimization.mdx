---
title: "React 성능 최적화 완벽 가이드: 메모이제이션부터 코드 스플리팅까지"
thumbnail: "/mdx-images/react/performance.png"
slug: "react-performance-optimization"
description: >
  React 애플리케이션의 성능을 최적화하는 다양한 기법들을 알아봅니다. 
  React.memo, useMemo, useCallback, 코드 스플리팅 등 실전에서 바로 
  적용할 수 있는 최적화 방법들을 소개합니다.
category: "React.js"
tags: ["React", "Performance", "Optimization", "Frontend"]
published: "2025-01-20"
---

React 애플리케이션의 성능을 향상시키는 것은 사용자 경험에 직접적인 영향을 미칩니다. 이 글에서는 React에서 사용할 수 있는 다양한 성능 최적화 기법들을 알아보겠습니다.

## React.memo로 불필요한 리렌더링 방지

React.memo는 props가 변경되지 않았을 때 컴포넌트의 리렌더링을 방지합니다.

```jsx
import React from "react";

const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  console.log("ExpensiveComponent 렌더링");

  return (
    <div>
      <h3>복잡한 계산 결과</h3>
      <p>{data.map((item) => item.value).join(", ")}</p>
      <button onClick={onUpdate}>업데이트</button>
    </div>
  );
});

function ParentComponent() {
  const [count, setCount] = React.useState(0);
  const [data, setData] = React.useState([
    { id: 1, value: "A" },
    { id: 2, value: "B" },
  ]);

  const handleUpdate = React.useCallback(() => {
    setData((prev) => [...prev, { id: Date.now(), value: "C" }]);
  }, []);

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>카운트 증가</button>
      <ExpensiveComponent data={data} onUpdate={handleUpdate} />
    </div>
  );
}
```

## useMemo로 값 메모이제이션

useMemo는 계산 비용이 큰 값을 메모이제이션하여 성능을 향상시킵니다.

```jsx
import React, { useMemo } from "react";

function DataVisualization({ data, filter }) {
  const processedData = useMemo(() => {
    console.log("데이터 처리 중...");
    return data
      .filter((item) => item.category === filter)
      .map((item) => ({
        ...item,
        processedValue: item.value * 2 + Math.sqrt(item.value),
      }))
      .sort((a, b) => b.processedValue - a.processedValue);
  }, [data, filter]);

  return (
    <div>
      <h3>처리된 데이터</h3>
      <ul>
        {processedData.map((item) => (
          <li key={item.id}>
            {item.name}: {item.processedValue.toFixed(2)}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## useCallback으로 함수 메모이제이션

useCallback은 함수를 메모이제이션하여 자식 컴포넌트의 불필요한 리렌더링을 방지합니다.

```jsx
import React, { useCallback, useState } from "react";

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState("");

  const addTodo = useCallback((text) => {
    setTodos((prev) => [
      ...prev,
      {
        id: Date.now(),
        text,
        completed: false,
      },
    ]);
  }, []);

  const toggleTodo = useCallback((id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }, []);

  const removeTodo = useCallback((id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id));
  }, []);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      addTodo(inputValue.trim());
      setInputValue("");
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="할 일을 입력하세요"
        />
        <button type="submit">추가</button>
      </form>

      <TodoItems todos={todos} onToggle={toggleTodo} onRemove={removeTodo} />
    </div>
  );
}

const TodoItems = React.memo(({ todos, onToggle, onRemove }) => {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
          />
          <span
            style={{ textDecoration: todo.completed ? "line-through" : "none" }}
          >
            {todo.text}
          </span>
          <button onClick={() => onRemove(todo.id)}>삭제</button>
        </li>
      ))}
    </ul>
  );
});
```

## 코드 스플리팅으로 번들 크기 최적화

React.lazy와 Suspense를 사용하여 코드 스플리팅을 구현할 수 있습니다.

```jsx
import React, { Suspense, lazy } from "react";

// 지연 로딩할 컴포넌트들
const Dashboard = lazy(() => import("./Dashboard"));
const Settings = lazy(() => import("./Settings"));
const Profile = lazy(() => import("./Profile"));

function App() {
  const [currentPage, setCurrentPage] = React.useState("dashboard");

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard":
        return <Dashboard />;
      case "settings":
        return <Settings />;
      case "profile":
        return <Profile />;
      default:
        return <Dashboard />;
    }
  };

  return (
    <div>
      <nav>
        <button onClick={() => setCurrentPage("dashboard")}>대시보드</button>
        <button onClick={() => setCurrentPage("settings")}>설정</button>
        <button onClick={() => setCurrentPage("profile")}>프로필</button>
      </nav>

      <Suspense fallback={<div>로딩 중...</div>}>{renderPage()}</Suspense>
    </div>
  );
}
```

## 마무리

React 성능 최적화는 애플리케이션의 사용자 경험을 크게 향상시킬 수 있습니다. 이 글에서 소개한 기법들을 적절히 활용하여 더 빠르고 반응성 좋은 React 애플리케이션을 만들어보세요. 다음 글에서는 더 고급 최적화 기법과 성능 측정 방법에 대해 알아보겠습니다.
