---
title: "Rust 소유권에 대한 이해"
thumbnail: "/mdx-images/rust/rust-programming.jpg"
slug: "rust-ownership"
description: >
  러스트의 가장 유니크한 특성이며, 러스트가 GC 없이 메모리 안정성을 보장하게해주는 소유권에 대한 이해
category: "Rust"
tags: ["Rust"]
published: "2025-09-21"
---

## Stack 영역과 Heap 영역

보통의 프로그래밍 언어에서는 stack, heap 영역을 주체로 고민할 필요가 많지는 않지만 러스트 시스템 프로그래밍에서는 값을 ~stack~에 저장하느냐 ~heap~에 저장하느냐에 차이가 프로그램의 동작및 의사 결정에 큰 영향을 미친다.

stack과 heap 모두 런타임에 이용하게 될 메모리 영역이라는 공통점이 있지만, 그 구조는 다르다.

### stack의 동작

stack은 값이 들어온 순서대로 저장하고, 역순으로 제거된다.(LIFO)

### heap의 동작

heap은 stack보다 좀 더 복잡하게 동작하는데 먼저 값이 heap에 저장될 때 OS에 저장할 공간이 있는지를 먼저 확인한다 그러면 메모리 할당자는 heap영역에서 어떤 빈 지점을 찾고, 해당 지점은 사용 중 표시를 하고 해당 지점을 가리키는 pointer를 반환한다.

이 일련의 과정을 힙 공간 할당 줄여서 allocation이라 한다.

#### Stack, Heap의 속도

**stack이 더 빠르다**

Stack 영역은 데이터에 접근하는 방식상 힙 영역보다 속도가 빠르다.

반면에 Heap에 공간을 할당하는 작업은 좀 더 많은 작업을 요구하는데, 메모리 할당자가 데이터를 저장하기 충분한 공간을 먼저 찾고 다음 할당을 위한 준비를 위해 예약을 수행해야 하기 때문.

Heap 영역은 저장(write)뿐 아니라 읽기(read)도 Stack에 비해 느리가 프로세서가 메모리 내부를 돌아다니며 저장된 공간을 찾아야하기 때문.

코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 소유권과 관련되어 있다.

반대로 말하면 소유권을 한번 이해하고 나면 스택, 힙 영역으로 고민할 일이 줄어들 거란 뜻이지만, 소유권의 주요 목표가 힙 데이터의 관리라는 점을 알고 있으면 소유권의 동작 방식을 이해하는 데 도움이 된다.

<hr />

## 소유권 규칙

1. 러스트에서, 각각의 값은 소유자(owner)가 정해져있다.
2. 한 값의 소유자는 동시에 여렷 존재할 수 없다. (1값에 1의 소유자)
3. 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다 (dropped)

## 메모리와 할당

allocation(할당)과 free(해제)가 하나의 짝으로 동작해야 프로그램의 안정성을 보장할 수 있다.  
러스트에서는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제(free)하는 방식으로 해결했다.

```rust
{
  let s = String::from("hello");
}
// s??
// 해당 스코프에 도달하게되면 Rust가 drop함수를 호출해 s변수의 메모리를 해제한다.
```

## 소유권 개념이 Rust에서 중요한 이유

```rust
  let x = 5;
  let y = x;
```

위 코드는 x에 5를 바인딩하고 y에 x값의 복사본을 만들어 y에 바인딩된다.  
고정된 크기를 가진 데이터 타입을 다루기 때문에 2개의 5값은 스택에 push된다.

```rust
  let s1 = String::from("Hello");
  let s2 = s1;
```

이전 코드와 비슷하나 String타입은 가변 길이를 가지는 데이터 타입으로 Heap에 저장되며 아래와 같은 일이 이루어진다.

String은 아래와 같이 문자열의 정보를 가진 데이터는 Stack에 저장된다. (포인터, 길이, 용량)

|  이름  |  값   |
| :----: | :---: |
| 포인터 | 0x001 |
|  길이  |   5   |
|  용량  |   5   |

반면 실제 값이 들어있는 "Hello"는 Heap에 저장되어있다.

| index | 값  |
| :---: | :-: |
|   0   |  H  |
|   1   |  e  |
|   2   |  l  |
|   3   |  l  |
|   4   |  0  |

`let s2 = s1;` 해당 구문에서 s1의 데이터가 복사되어야 하는데 스택에 저장된 데이터 즉, 포인터(메모리 주소), 길이, 용량 값을 복사하며 Heap 영역에 있는 값은 복사되지 않는다.

즉 s1할당시 Heap에 할당되고 s2에 s1을 할당할 때는 (실제 할당이 이루어지진 않음) s1의 stack에 저장된 데이터를 복사하게 된다.

여기서 문제가 발생하는데 Rust에서는 스코프를 벗어나게 되면 메모리를 자동 해제하는 동작을 가진다  
 s1, s2 모두 하나의 Heap 데이터를 가지고있고 2개중 하나라도 스코프를 벗어나면 Heap에 데이터가 해제되는데 그렇게 될 경우 중복 해제(double free) 에러가 발생하게 된다.

이는 메모리 안정성 버그 중 하나로, 보안을 취약하게 만드는 메모리 손상의 원인이다.

**Rust가 위 문제를 해결하기위해 선택한 방법**

```rust
  let s1 = String::from("Hello");
  let s2 = s1; // 해당 시점에서 s1의 소유권이 넘어가 s1은 유효하지 않게 된다고 판단한다.
```

heap데이터를 복사하지 않고 포인터, 길이, 용량 값만 복사하는 것을 얕은 복사라고 착각할 수 있는데  
러스트에서는 **move**(소유권 이동)라고 한다.

`덧붙이자면, 러스트는 절대 자동으로 ‘깊은’ 복사로 데이터를 복사하는 일이 없습니다. 따라서, 러스트가 자동으로 수행하는 모든 복사는 런타임 성능 측면에서 효율적이라 할 수 있습니다.`

그렇다면 실제 Heap데이터 까지 복사하고싶다면 어떻게 하면 될까?

```rust
  let s1: String::from("Hello");
  let s2 = s1.clone();
```

clone()을 호출해 s1의 값을 복사하게되면 Heap영역에 실제 값이 복사되어 같은 값이 2개 존재하게 된다.

clone 호출을 보고, 이 지점에서 성능에 영향이 갈 수도 있는 코드가 실행될 것을 알 수 있다. 즉, clone은 해당 위치에서 무언가 다른 일이 수행될 것을 알려주는 시각적인 표시이기도 하다.

### 추가 내용

```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문에 복사본을 빠르게 만들 수 있고 굳이 y를 생성하고 x를 무효화할 필요가 없다.

Rust에서는 정수형 처럼 스택에 저장되는 타입에 달아 놓을 수 있는 Copy ~트레이트~가 있다.

만약 어떤 타입이 Copy 트레이트가 구현되어 있다면, 해당 타입의 변수는 사용되어도 이동되지 않고 자명하게 복사되어, 대입 연산 이후에도 사용할 수 있다는 뜻이다.
