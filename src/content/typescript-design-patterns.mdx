---
title: "TypeScript 디자인 패턴 완벽 가이드: 싱글톤부터 옵저버까지"
thumbnail: "/mdx-images/typescript/design-patterns.png"
slug: "typescript-design-patterns"
description: >
  TypeScript에서 구현하는 디자인 패턴들을 알아봅니다. 
  싱글톤, 팩토리, 옵저버, 전략 패턴 등 실전에서 자주 사용되는 
  디자인 패턴들을 TypeScript의 타입 시스템과 함께 구현해보세요.
category: "TypeScript"
tags: ["TypeScript", "Design Patterns", "Architecture", "Best Practices"]
published: "2025-01-30"
---

## 싱글톤 패턴 (Singleton Pattern)

싱글톤 패턴은 클래스의 인스턴스가 하나만 생성되도록 보장하는 패턴입니다.

```typescript
class DatabaseConnection {
  private static instance: DatabaseConnection | null = null;
  private connectionString: string;

  private constructor(connectionString: string) {
    this.connectionString = connectionString;
  }

  public static getInstance(connectionString?: string): DatabaseConnection {
    if (!DatabaseConnection.instance) {
      if (!connectionString) {
        throw new Error(
          "첫 번째 인스턴스 생성 시 connectionString이 필요합니다."
        );
      }
      DatabaseConnection.instance = new DatabaseConnection(connectionString);
    }
    return DatabaseConnection.instance;
  }

  public connect(): void {
    console.log(`데이터베이스에 연결 중: ${this.connectionString}`);
  }

  public disconnect(): void {
    console.log("데이터베이스 연결 해제");
  }
}

// 사용 예시
const db1 = DatabaseConnection.getInstance("postgresql://localhost:5432/mydb");
const db2 = DatabaseConnection.getInstance(); // 같은 인스턴스 반환

console.log(db1 === db2); // true
```

## 팩토리 패턴 (Factory Pattern)

팩토리 패턴은 객체 생성 로직을 캡슐화하여 유연성을 높이는 패턴입니다.

```typescript
// 제품 인터페이스
interface Vehicle {
  start(): void;
  stop(): void;
  getInfo(): string;
}

// 구체적인 제품들
class Car implements Vehicle {
  private model: string;

  constructor(model: string) {
    this.model = model;
  }

  start(): void {
    console.log(`${this.model} 자동차가 시동을 겁니다.`);
  }

  stop(): void {
    console.log(`${this.model} 자동차가 정지합니다.`);
  }

  getInfo(): string {
    return `자동차 모델: ${this.model}`;
  }
}

class Motorcycle implements Vehicle {
  private brand: string;

  constructor(brand: string) {
    this.brand = brand;
  }

  start(): void {
    console.log(`${this.brand} 오토바이가 시동을 겁니다.`);
  }

  stop(): void {
    console.log(`${this.brand} 오토바이가 정지합니다.`);
  }

  getInfo(): string {
    return `오토바이 브랜드: ${this.brand}`;
  }
}

// 팩토리 클래스
class VehicleFactory {
  public static createVehicle(
    type: "car" | "motorcycle",
    model: string
  ): Vehicle {
    switch (type) {
      case "car":
        return new Car(model);
      case "motorcycle":
        return new Motorcycle(model);
      default:
        throw new Error(`지원하지 않는 차량 타입: ${type}`);
    }
  }
}

// 사용 예시
const car = VehicleFactory.createVehicle("car", "Tesla Model 3");
const motorcycle = VehicleFactory.createVehicle("motorcycle", "Honda");

car.start();
motorcycle.start();
```

## 옵저버 패턴 (Observer Pattern)

옵저버 패턴은 객체 간의 일대다 의존성을 정의하여 한 객체의 상태가 변경될 때 모든 의존자들이 자동으로 알림을 받는 패턴입니다.

```typescript
// 옵저버 인터페이스
interface Observer {
  update(data: any): void;
}

// 주제 인터페이스
interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(): void;
}

// 구체적인 주제 클래스
class NewsAgency implements Subject {
  private observers: Observer[] = [];
  private news: string = "";

  attach(observer: Observer): void {
    const isExist = this.observers.includes(observer);
    if (isExist) {
      return console.log("이미 구독 중인 옵저버입니다.");
    }
    this.observers.push(observer);
    console.log("옵저버가 구독되었습니다.");
  }

  detach(observer: Observer): void {
    const observerIndex = this.observers.indexOf(observer);
    if (observerIndex === -1) {
      return console.log("구독하지 않은 옵저버입니다.");
    }
    this.observers.splice(observerIndex, 1);
    console.log("옵저버 구독이 해제되었습니다.");
  }

  notify(): void {
    console.log("모든 옵저버에게 뉴스를 전송합니다.");
    for (const observer of this.observers) {
      observer.update(this.news);
    }
  }

  setNews(news: string): void {
    this.news = news;
    this.notify();
  }
}

// 구체적인 옵저버 클래스들
class NewsChannel implements Observer {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  update(news: string): void {
    console.log(`${this.name} 채널이 뉴스를 받았습니다: ${news}`);
  }
}

// 사용 예시
const newsAgency = new NewsAgency();

const channel1 = new NewsChannel("CNN");
const channel2 = new NewsChannel("BBC");

newsAgency.attach(channel1);
newsAgency.attach(channel2);

newsAgency.setNews("중요한 뉴스가 발생했습니다!");
```

## 전략 패턴 (Strategy Pattern)

전략 패턴은 알고리즘을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 패턴입니다.

```typescript
// 전략 인터페이스
interface PaymentStrategy {
  pay(amount: number): void;
}

// 구체적인 전략들
class CreditCardPayment implements PaymentStrategy {
  private cardNumber: string;
  private cvv: string;

  constructor(cardNumber: string, cvv: string) {
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }

  pay(amount: number): void {
    console.log(
      `${amount}원을 신용카드로 결제합니다. 카드번호: ${this.cardNumber}`
    );
  }
}

class PayPalPayment implements PaymentStrategy {
  private email: string;

  constructor(email: string) {
    this.email = email;
  }

  pay(amount: number): void {
    console.log(`${amount}원을 PayPal로 결제합니다. 이메일: ${this.email}`);
  }
}

class CashPayment implements PaymentStrategy {
  pay(amount: number): void {
    console.log(`${amount}원을 현금으로 결제합니다.`);
  }
}

// 컨텍스트 클래스
class ShoppingCart {
  private paymentStrategy: PaymentStrategy | null = null;

  setPaymentStrategy(strategy: PaymentStrategy): void {
    this.paymentStrategy = strategy;
  }

  checkout(amount: number): void {
    if (!this.paymentStrategy) {
      throw new Error("결제 방법을 선택해주세요.");
    }
    this.paymentStrategy.pay(amount);
  }
}

// 사용 예시
const cart = new ShoppingCart();

// 신용카드로 결제
cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456", "123"));
cart.checkout(50000);

// PayPal로 결제
cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
cart.checkout(30000);

// 현금으로 결제
cart.setPaymentStrategy(new CashPayment());
cart.checkout(15000);
```

## 마무리

TypeScript의 타입 시스템을 활용한 디자인 패턴 구현은 코드의 안전성과 유지보수성을 크게 향상시킵니다. 이 글에서 소개한 패턴들을 실전 프로젝트에 적용하여 더 견고하고 확장 가능한 코드를 작성해보세요. 다음 글에서는 더 고급 디자인 패턴과 실전 활용 사례에 대해 알아보겠습니다.
