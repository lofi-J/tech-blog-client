---
title: "JavaScript 함수형 프로그래밍 완벽 가이드: 순수함수부터 모나드까지"
thumbnail: "/mdx-images/javascript/javascript-functional.webp"
slug: "javascript-functional-programming"
description: >
  JavaScript에서 함수형 프로그래밍을 구현하는 방법을 알아봅니다. 
  순수함수, 고차함수, 커링, 합성, 모나드 등 함수형 프로그래밍의 
  핵심 개념들을 실전 예제와 함께 학습해보세요.
category: "JavaScript"
tags: ["JavaScript", "Functional Programming", "Pure Functions", "Monads"]
published: "2025-02-10"
---

## 순수함수 (Pure Functions)

순수함수는 같은 입력에 대해 항상 같은 출력을 반환하고, 부수효과가 없는 함수입니다.

~~이전에는 명령형 프로그래밍이 주로 사용되었지만~~, 함수형 프로그래밍이 더 안전하고 예측 가능한 코드를 작성할 수 있게 해줍니다.

```javascript
// 하이라이트된 라인 예시
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
```

```javascript
// 순수함수 예시
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const square = (x) => x * x;

// 순수하지 않은 함수 (부수효과 있음)
let total = 0;
const addToTotal = (amount) => {
  total += amount; // 외부 상태 변경
  return total;
};

// 순수함수로 개선
const addToTotalPure = (currentTotal, amount) => currentTotal + amount;

// 배열 조작에서 순수함수 사용
const numbers = [1, 2, 3, 4, 5];

// 순수하지 않은 방법 (원본 배열 변경)
const doubleNumbersImpure = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = arr[i] * 2;
  }
  return arr;
};

// 순수함수 방법 (새 배열 반환)
const doubleNumbersPure = (arr) => arr.map((x) => x * 2);

// 사용 예시
const doubled = doubleNumbersPure(numbers);
console.log(numbers); // [1, 2, 3, 4, 5] (원본 유지)
console.log(doubled); // [2, 4, 6, 8, 10] (새 배열)
```

## 고차함수 (Higher-Order Functions)

고차함수는 함수를 매개변수로 받거나 함수를 반환하는 함수입니다.

```javascript
// 함수를 매개변수로 받는 고차함수
const withLogging = (fn, name) => {
  return (...args) => {
    console.log(`함수 ${name} 호출됨:`, args);
    const result = fn(...args);
    console.log(`함수 ${name} 결과:`, result);
    return result;
  };
};

// 사용 예시
const add = (a, b) => a + b;
const addWithLogging = withLogging(add, "add");
addWithLogging(3, 5); // 로그와 함께 실행

// 함수를 반환하는 고차함수
const createMultiplier = (factor) => {
  return (number) => number * factor;
};

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// 배열 고차함수들
const users = [
  { id: 1, name: "Alice", age: 25, active: true },
  { id: 2, name: "Bob", age: 30, active: false },
  { id: 3, name: "Charlie", age: 35, active: true },
  { id: 4, name: "Diana", age: 28, active: true },
];

// filter, map, reduce 조합
const activeUserNames = users
  .filter((user) => user.active)
  .map((user) => user.name)
  .reduce((acc, name) => acc + ", " + name, "");

console.log(activeUserNames); // "Alice, Charlie, Diana"
```

## 커링 (Currying)

커링은 여러 매개변수를 받는 함수를 하나씩 받는 함수들의 체인으로 변환하는 기법입니다.

```javascript
// 기본 커링 함수
const curry = (fn) => {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function (...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
};

// 사용 예시
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6

// 실용적인 커링 예시
const multiply = (a) => (b) => a * b;
const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// 배열 처리에서 커링 활용
const filter = (predicate) => (array) => array.filter(predicate);
const map = (fn) => (array) => array.map(fn);
const reduce = (fn, initial) => (array) => array.reduce(fn, initial);

const isActive = (user) => user.active;
const getName = (user) => user.name;
const joinNames = (acc, name) => acc + ", " + name;

const getActiveUserNames = pipe(
  filter(isActive),
  map(getName),
  reduce(joinNames, "")
);

console.log(getActiveUserNames(users)); // "Alice, Charlie, Diana"
```

## 함수 합성 (Function Composition)

함수 합성은 여러 함수를 조합하여 새로운 함수를 만드는 기법입니다.

```javascript
// 기본 합성 함수
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((acc, fn) => fn(acc), x);
const pipe =
  (...fns) =>
  (x) =>
    fns.reduce((acc, fn) => fn(acc), x);

// 사용 예시
const addOne = (x) => x + 1;
const double = (x) => x * 2;
const square = (x) => x * x;

// compose: 오른쪽에서 왼쪽으로 실행
const composed = compose(square, double, addOne);
console.log(composed(3)); // ((3 + 1) * 2)² = 64

// pipe: 왼쪽에서 오른쪽으로 실행
const piped = pipe(addOne, double, square);
console.log(piped(3)); // ((3 + 1) * 2)² = 64

// 실전 예시: 사용자 데이터 처리
const users = [
  { name: "Alice", age: 25, score: 85 },
  { name: "Bob", age: 30, score: 92 },
  { name: "Charlie", age: 35, score: 78 },
  { name: "Diana", age: 28, score: 95 },
];

const filterByAge = (minAge) => (users) =>
  users.filter((user) => user.age >= minAge);

const sortByScore = (users) => users.sort((a, b) => b.score - a.score);

const takeTop = (n) => (users) => users.slice(0, n);

const getNames = (users) => users.map((user) => user.name);

// 파이프라인 구성
const getTopYoungUsers = pipe(
  filterByAge(25),
  sortByScore,
  takeTop(2),
  getNames
);

console.log(getTopYoungUsers(users)); // ['Diana', 'Bob']
```

## 모나드 (Monads)

모나드는 부수효과를 안전하게 처리할 수 있게 해주는 구조입니다.

```javascript
// Maybe 모나드
class Maybe {
  constructor(value) {
    this.value = value;
  }

  static of(value) {
    return new Maybe(value);
  }

  map(fn) {
    return this.value === null || this.value === undefined
      ? Maybe.of(null)
      : Maybe.of(fn(this.value));
  }

  flatMap(fn) {
    return this.value === null || this.value === undefined
      ? Maybe.of(null)
      : fn(this.value);
  }

  getOrElse(defaultValue) {
    return this.value === null || this.value === undefined
      ? defaultValue
      : this.value;
  }
}

// 사용 예시
const user = {
  name: "John",
  address: {
    street: "123 Main St",
    city: "Seoul",
  },
};

const getUserCity = (user) =>
  Maybe.of(user)
    .map((u) => u.address)
    .map((addr) => addr.city)
    .getOrElse("Unknown");

console.log(getUserCity(user)); // 'Seoul'
console.log(getUserCity({})); // 'Unknown'

// Either 모나드
class Either {
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }

  static left(value) {
    return new Either(value, null);
  }

  static right(value) {
    return new Either(null, value);
  }

  map(fn) {
    return this.right !== null
      ? Either.right(fn(this.right))
      : Either.left(this.left);
  }

  flatMap(fn) {
    return this.right !== null ? fn(this.right) : Either.left(this.left);
  }

  fold(leftFn, rightFn) {
    return this.right !== null ? rightFn(this.right) : leftFn(this.left);
  }
}

// 사용 예시
const divide = (a, b) => {
  return b === 0 ? Either.left("0으로 나눌 수 없습니다") : Either.right(a / b);
};

const result = divide(10, 2)
  .map((x) => x * 2)
  .fold(
    (error) => `에러: ${error}`,
    (value) => `결과: ${value}`
  );

console.log(result); // '결과: 10'
```

## 다양한 언어 예시

### TypeScript 예시

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

type UserStatus = "active" | "inactive" | "pending";

class UserService {
  private users: User[] = [];

  async getUserById(id: number): Promise<User | null> {
    return this.users.find((user) => user.id === id) || null;
  }

  async updateUserStatus(id: number, status: UserStatus): Promise<User> {
    const user = await this.getUserById(id);
    if (!user) {
      throw new Error(`User with id ${id} not found`);
    }

    return { ...user, isActive: status === "active" };
  }
}
```

### CSS 예시

```css
.user-card {
  display: flex;
  flex-direction: column;
  padding: 1rem;
  border-radius: 8px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease-in-out;
}

.user-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
}

.user-avatar {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid rgba(255, 255, 255, 0.3);
}

.user-info {
  margin-top: 1rem;
  color: white;
}

.user-name {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.user-email {
  font-size: 0.875rem;
  opacity: 0.9;
}
```

### Rust 예시

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
    is_active: bool,
}

impl User {
    fn new(id: u32, name: String, email: String) -> Self {
        User {
            id,
            name,
            email,
            is_active: true,
        }
    }

    fn deactivate(&mut self) {
        self.is_active = false;
    }

    fn activate(&mut self) {
        self.is_active = true;
    }
}

fn main() {
    let mut users: HashMap<u32, User> = HashMap::new();

    let user1 = User::new(1, "Alice".to_string(), "alice@example.com".to_string());
    let user2 = User::new(2, "Bob".to_string(), "bob@example.com".to_string());

    users.insert(user1.id, user1);
    users.insert(user2.id, user2);

    if let Some(user) = users.get_mut(&1) {
        user.deactivate();
        println!("User deactivated: {:?}", user);
    }
}
```

### JSX 예시

```jsx
import React, { useState, useEffect } from "react";

const UserCard = ({ user, onStatusChange }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [status, setStatus] = useState(user.isActive ? "active" : "inactive");

  const handleStatusToggle = async () => {
    setIsLoading(true);
    try {
      const newStatus = status === "active" ? "inactive" : "active";
      await onStatusChange(user.id, newStatus);
      setStatus(newStatus);
    } catch (error) {
      console.error("Failed to update status:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} className="user-avatar" />
      <div className="user-info">
        <h3 className="user-name">{user.name}</h3>
        <p className="user-email">{user.email}</p>
        <button
          onClick={handleStatusToggle}
          disabled={isLoading}
          className={`status-button ${status}`}
        >
          {isLoading ? "Updating..." : status}
        </button>
      </div>
    </div>
  );
};

export default UserCard;
```

## 마무리

함수형 프로그래밍은 JavaScript에서 더 안전하고 예측 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서 소개한 개념들을 실전 프로젝트에 적용하여 더 견고하고 유지보수하기 쉬운 코드를 작성해보세요. 다음 글에서는 더 고급 함수형 프로그래밍 패턴과 실전 활용 사례에 대해 알아보겠습니다.
