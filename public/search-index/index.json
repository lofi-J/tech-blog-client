[
  {
    "metadata": {
      "title": "Rust 소유권에 대한 이해",
      "slug": "rust-ownership",
      "thumbnail": "/mdx-images/rust/rust-programming.jpg",
      "description": "러스트의 가장 유니크한 특성이며, 러스트가 GC 없이 메모리 안정성을 보장하게해주는 소유권에 대한 이해\n",
      "category": "Rust",
      "tags": [
        "Rust"
      ],
      "published": "2025-09-21"
    },
    "content": "## Stack 영역과 Heap 영역보통의 프로그래밍 언어에서는 stack, heap 영역을 주체로 고민할 필요가 많지는 않지만 러스트 시스템 프로그래밍에서는 값을 ~stack~에 저장하느냐 ~heap~에 저장하느냐에 차이가 프로그램의 동작및 의사 결정에 큰 영향을 미친다.stack과 heap 모두 런타임에 이용하게 될 메모리 영역이라는 공통점이 있지만, 그 구조는 다르다.### stack의 동작stack은 값이 들어온 순서대로 저장하고, 역순으로 제거된다.(LIFO)### heap의 동작heap은 stack보다 좀 더 복잡하게 동작하는데 먼저 값이 heap에 저장될 때 OS에 저장할 공간이 있는지를 먼저 확인한다 그러면 메모리 할당자는 heap영역에서 어떤 빈 지점을 찾고, 해당 지점은 사용 중 표시를 하고 해당 지점을 가리키는 pointer를 반환한다.이 일련의 과정을 힙 공간 할당 줄여서 allocation이라 한다.#### Stack, Heap의 속도**stack이 더 빠르다**Stack 영역은 데이터에 접근하는 방식상 힙 영역보다 속도가 빠르다.반면에 Heap에 공간을 할당하는 작업은 좀 더 많은 작업을 요구하는데, 메모리 할당자가 데이터를 저장하기 충분한 공간을 먼저 찾고 다음 할당을 위한 준비를 위해 예약을 수행해야 하기 때문.Heap 영역은 저장(write)뿐 아니라 읽기(read)도 Stack에 비해 느리가 프로세서가 메모리 내부를 돌아다니며 저장된 공간을 찾아야하기 때문.코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 소유권과 관련되어 있다.반대로 말하면 소유권을 한번 이해하고 나면 스택, 힙 영역으로 고민할 일이 줄어들 거란 뜻이지만, 소유권의 주요 목표가 힙 데이터의 관리라는 점을 알고 있으면 소유권의 동작 방식을 이해하는 데 도움이 된다.<hr />## 소유권 규칙1. 러스트에서, 각각의 값은 소유자(owner)가 정해져있다.2. 한 값의 소유자는 동시에 여렷 존재할 수 없다. (1값에 1의 소유자)3. 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다 (dropped)## 메모리와 할당allocation(할당)과 free(해제)가 하나의 짝으로 동작해야 프로그램의 안정성을 보장할 수 있다.  러스트에서는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제(free)하는 방식으로 해결했다.```rust{  let s = String::from(\"hello\");}// s??// 해당 스코프에 도달하게되면 Rust가 drop함수를 호출해 s변수의 메모리를 해제한다.```## 소유권 개념이 Rust에서 중요한 이유```rust  let x = 5;  let y = x;```위 코드는 x에 5를 바인딩하고 y에 x값의 복사본을 만들어 y에 바인딩된다.  고정된 크기를 가진 데이터 타입을 다루기 때문에 2개의 5값은 스택에 push된다.```rust  let s1 = String::from(\"Hello\");  let s2 = s1;```이전 코드와 비슷하나 String타입은 가변 길이를 가지는 데이터 타입으로 Heap에 저장되며 아래와 같은 일이 이루어진다.String은 아래와 같이 문자열의 정보를 가진 데이터는 Stack에 저장된다. (포인터, 길이, 용량)|  이름  |  값   || :"
  },
  {
    "metadata": {
      "title": "HTML script 태그에 대해",
      "slug": "html-script-tag",
      "thumbnail": "/mdx-images/html/html-script.png",
      "description": "HTML script태그 사용법과 주의 사항에 대해\n",
      "category": "HTML",
      "tags": [
        "HTML",
        "Tag",
        "script"
      ],
      "published": "2025-09-08"
    },
    "content": "## script 태그?"
  },
  {
    "metadata": {
      "title": "Git 개념과 사용법",
      "slug": "git-simple-concept",
      "thumbnail": "/mdx-images/git/bg-git.jpg",
      "description": "Git을 처음 다루는 취준생 및 신입 개발자를 위한 개념, 명령어 정리\n",
      "category": "Git",
      "tags": [
        "Git",
        "Github"
      ],
      "published": "2025-09-02"
    },
    "content": "## Git?Git은 파일의 변경 사항을 추적하고 여러 명의 사용자 간 작업을 효율적으로 수행하기 위한 ~스냅샷~ 스트림 기반의 버전 관리 시스템입니다각 ~커밋~ 시점에서의 전체 ~스냅샷~을 저장하고 커밋들은 시간순으로 연결되어 스냅샵 스트림을 형성하게 됩니다.## Git의 무결성Git은 데이터를 저장할 때 항상 체크섬을 생성해 그 ~체크섬~을 기반으로 프로젝트를 관리합니다.~SHA-1~ 해시를 사용하고 파일의 내용 및 디렉터리 구조를 이용해 체크섬을 생성하게 됩니다.## Git 상태(중요)Git에서는 파일들을 _untracked_, _Modified_, _Staged_, _Committed_ 이렇게 4가지의 주요 상태들로 관리합니다.git init(untracked) -> 파일 수정(modified) -> add(staged) -> commit(committed)- Untracked : Git이 추적하지 않는 새 파일- Modified : 수정한 파일이 아직 로컬 저장소에 저장(commit)되지 않은 것을 의미- Staged : 현재 수정한 파일이 곧 커밋할 것이라고 표시(add)해 놓은 상태를 의미- Committed : 데이터가 로컬 저장소에 저장(commit)됐다는 것을 의미## Git 간단하게 시작하기작업 폴더에서 `git init`을 수행하거나 다른 저장소의 `git clone`을 받은 경우 .git이라는 폴더가 생성됩니다..git 폴더는 Git 저장소의 모든 메타데이터와 객체 데이터베이스가 저장되는 디렉토리로 프로젝트의 전체 버전 관리 정보를 담고 있는 Git의 핵심 저장소입니다.여러분들의 작업 폴더(root)에 .git 폴더가 생성되었으면 Git 명령어들을 통해 파일들을 관리할 수 있게됩니다.`git add .` 명령어를 이용해 Modified 상태의 파일들을 모두 Staged 상태로 옮길 수 있습니다.`git commit -m \"커밋 메세지\"` 명령어를 통해 Staged 상태를 Commited 상태로 만듭니다 (스냅샵 생성)## Branch?![Git branch image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiVsirC1iUZWOmt8Fo-pAdgGX94rhiycaZMw05FURMvYE9VrlSWhtV1xq6OotVOcc-2mYGcHEL1iJYrUr1FsbySHIpkVH_SkQF9I3-Bbbjap0p-8EnBTNKcfQbTMaLhVFui7JxeiO4trI0/s1600/git_branching_simple.png)여러명에서 개발을 하다보면 어떤 개발자는 버그를 수정하고, 어떤 개발자는 새로운 기능을 개발하는 서로 다른 작업을 하다보면 각각 서로 다른 버전의 코드가 만들어 지게됩니다.이럴 때 여러 개발자가 동시에 다른 작업을 할 수 있게 만들어주는 기능이 ~브랜치~(branch)입니다.각자 독립된 작업영역안에서 소스코드를 작성하고 변경/추가된 내용을 원래의 버전과 비교/병합하여 하나의 새로운 버전으로 만들어 낼 수 있습니다.### 브랜치 생성```bash# 새 브랜치 생성 (생성만, 전환하지 않음)git branch feature-login# 브랜치 생성과 동시에 전환git checkout -b feature-login# 또는git switch -c feature-login```### 현재 위치한 브랜치 전환```bash# 브랜치 전환git checkout feature-login# 또는git switch feature-login```### 브랜치 관리 명령어```bash# 브랜치 목록 확인git branch# 원격 브랜치 포함 모든 브랜치 확인git branch -a# 브랜치 삭제 (안전한 삭제)git branch -d feature-name# 브랜치 강제 삭제git branch -D feature-name# 브랜치 이름 변경git branch -m old-name new-name```## Git과 GitHubGit은 버전 관리 도구이고, GitHub은 Git 저장소를 호스팅하는 클라우드 서비스입니다.- Git : 개발자의 컴퓨터에 설치되어 로컬에서 파일의 변경 이력을 추적하고 관리합니다.- GitHub : Git 저장소를 인터넷 상에 저장하고 공유할 수 있게 해주는 서비스입니다, 개발자가 로컬에서 Git으로 관리하던 프로젝트를 GitHub에 업로드하면, 다른 개발자들과 협업하거나 코드를 공유할 수 있게 됩니다.## 원격 저장소?원격 저장소(Remote Repository)는 네트워크상의 다른 위치에 존재하는 Git 저장소를 의미합니다. 여러 개발자가 동일한 프로젝트에서 협업할 수 있게 해주는 Git의 핵심 기능 중 하나입니다.단순히 말하면 다른 곳에 위치한 Git 저장소입니다(예시)- 개인 서버: 개발자가 직접 운영하는 서버- 회사 내부 서버: 팀 또는 조직이 관리하는 서버- 클라우드 호스팅 서비스: GitHub, GitLab, Bitbucket 등## 원격 저장소 관련 Git명령어### git remotegit remote 명령어는 다른 저장소에 대한 연결을 생성, 조회, 삭제하는 인터페이스입니다.```bash# 원격 저장소 추가git remote add origin https://github.com/username/repository.git# 원격 저장소 목록 확인git remote -v# 원격 저장소 이름 변경git remote rename old-name new-name# 원격 저장소 제거git remote rm origin```### 네트워크 관련 Git명령어- git clone : git clone으로 저장소를 복제하면 자동으로 복제된 저장소를 가리키는 origin이라는 원격 연결을 생성합니다.- git fetch : 원격 저장소에서 데이터를 가져오지만 자동으로 병합하지 않습니다. (사용성 관점에서는 새로고침이라 생각해도 무방합니다)- git pull : 원격 저장소에서 데이터를 가져와 현재 브랜치에 자동으로 병합합니다. (git fetch + git merge)- git push : 로컬 변경사항을 원격 저장소에 업로드합니다.## 정리### 일상적인 개발 Case```bash# 1. 최신 상태로 동기화git pull origin main# 다른 팀원들의 최신 작업 내용 가져오기# 2. 새 기능 브랜치 생성git checkout -b feature/user-login# 독립적인 작업 공간 생성# 3. 개발 작업# 파일 수정...git add .git commit -m \"~기능 개발함\"git commit -m \"~버그 수정함\"# 로컬에서 점진적으로 커밋 생성# 4. 원격에 브랜치 업로드git push origin feature/user-login# 팀원들과 작업 내용 공유# 5. GitHub에서 Pull Request 생성 (웹 인터페이스)# 코드 리뷰# 6. 메인 브랜치에 병합 후 정리git checkout maingit pull origin main          # 병합된 최신 상태 가져오기git branch -d feature/user-login    # 로컬 브랜치 삭제```### 새 프로젝트 생성 Case```bash# 1. 로컬 Git 저장소 초기화git init# 결과: .git 폴더 생성, 아직 커밋이나 원격 저장소 없음# 2. 프로젝트 파일 생성 및 첫 커밋echo \"# My Project\" > README.mdgit add README.mdgit commit -m \"Initial commit\"# 결과: 로컬에 첫 번째 스냅샷 생성# 3. GitHub에서 빈 저장소 생성 후 원격 저장소 연결git remote add origin https://github.com/username/my-project.git# 결과: 로컬 저장소와 원격 저장소 연결# 4. 로컬 커밋을 원격 저장소에 업로드git push -u origin main# 결과: 로컬의 모든 커밋이 GitHub에 업로드됨```### 기존 프로젝트 참여 Case```bash# 1. 원격 저장소를 로컬로 복제git clone https://github.com/username/existing-project.git# 결과: 전체 프로젝트와 히스토리가 로컬에 복사됨# origin 원격 저장소가 자동으로 설정됨# 2. 로컬에서 작업cd existing-projectecho \"새로운 기능\" > feature.jsgit add feature.jsgit commit -m \"Add new feature\"# 결과: 로컬에만 새 커밋 생성# 3. 원격 저장소에서 최신 변경사항 가져오기git pull origin main# 결과: 다른 개발자의 변경사항과 자동 병합# 4. 로컬 변경사항을 원격에 업로드git push origin main# 결과: 새 커밋이 원격 저장소에 반영됨```"
  },
  {
    "metadata": {
      "title": "간단한 JSP 프로젝트 구조 정리",
      "slug": "jsp-simple-start",
      "thumbnail": "/mdx-images/jsp/jsp-normal.png",
      "description": "JSP 프로젝트의 기본 구조에 대한 정리\n",
      "category": "JSP",
      "tags": [
        "JSP",
        "Java",
        "MVC",
        "Servlet",
        "웹개발"
      ],
      "published": "2025-09-05"
    },
    "content": "## JSP 프로젝트 기본 구조```txt 간략화한 폴더구조servlet-jsp-playground/├── pom.xml # Maven 설정├── src/│ ├── main/│ │ ├── java│ │ │  └── com.example.servletjspplayground│ │ │    └── HelloServlet.java│ │ └── webapp│ │   └── WEB-INF│ │     └── web.xml│ │   └── index.jsp│ │   └── header.jsp│ │   └── footer.jsp└── target/ # 빌드 결과```## 핵심 구성 요소### 서블릿(Servlet)웹 서버에서 동적인 웹 페이지를 생성하기 위한 서버 사이드 Java 프로그램입니다. \"Server + ~Applet~\"의 합성어로, 클라이언트의 HTTP 요청을 처리하고 동적인 응답을 생성하는 역할을 담당합니다.서블릿은 독립적으로 실행되지 않고, 서블릿 컨테이너(Tomcat, Jetty 등) 위에서 동작합니다. 컨테이너가 서블릿의 생명주기를 관리하고, HTTP 요청을 서블릿 메서드 호출로 변환해줍니다.MVC 역할에서 서블릿은 주로 컨트롤러(Controller) 역할을 담당합니다.#### 서블릿의 요청-응답 모델클라이언트의 HTTP 요청을 `HttpServletRequest` 객체로 받고, `HttpServletResponse` 객체를 통해 응답을 생성합니다.#### 서블릿 생명주기1: 로딩 및 인스턴스화 : 서블릿 컨테이너가 서블릿 클래스를 로드하고 인스턴스를 생성 <br />2: 초기화 (init)```java init예제public void init(ServletConfig config) throws ServletException {    // 서블릿 초기화 작업 (한 번만 실행)    // DB 연결, 설정 파일 로드 등}```3: 서비스 (service)```java service 예제protected void service(HttpServletRequest request, HttpServletResponse response)    throws ServletException, IOException {    // HTTP 메서드에 따라 doGet, doPost 등으로 분기}protected void doGet(HttpServletRequest request, HttpServletResponse response)    throws ServletException, IOException {    // GET 요청 처리 로직}protected void doPost(HttpServletRequest request, HttpServletResponse response)    throws ServletException, IOException {    // POST 요청 처리 로직}```4: 소멸 (destroy)```java destroy예제public void destroy() {    // 서블릿 종료 전 정리 작업    // 리소스 해제, 연결 종료 등}```#### 서블릿 예시```java@WebServlet(\"/user/*\")public class UserController extends HttpServlet {    protected void doGet(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException {        String pathInfo = request.getPathInfo();        if (\"/list\".equals(pathInfo)) {            // Model: 데이터 처리            List<User> users = userService.getAllUsers();            request.setAttribute(\"users\", users);            // View: JSP로 포워딩            RequestDispatcher dispatcher = request.getRequestDispatcher(\"/WEB-INF/views/userList.jsp\");            dispatcher.forward(request, response);        } else if (\"/detail\".equals(pathInfo)) {            // 사용자 상세 정보 처리        }    }}```### webapp 폴더webapp(Web Application) 폴더는 웹 서버가 직접 접근할 수 있는 공개 리소스 영역입니다. 클라이언트(브라우저)에서 HTTP 요청으로 직접 접근 가능한 모든 파일들이 이곳에 위치합니다.- JSP 파일들 (index.jsp, login.jsp 등)- HTML 파일들- 이미지, CSS, JavaScript 등 정적 리소스### WEB-INF 폴더 (특별한 보안 영역)WEB-INF(Web Information)는 Java Servlet 스펙에서 정의한 특별한 보안 디렉토리로, JSP/Servlet 웹 애플리케이션에서 핵심적인 역할을 담당합니다. webapp 폴더 내부에 위치하지만, 일반적인 웹 리소스와는 완전히 다른 접근 규칙을 가집니다.#### 접근 차단 메커니즘서블릿 컨테이너 레벨의 보안WEB-INF는 서블릿 컨테이너(Tomcat)가 HTTP 요청을 원천 차단하는 영역입니다. 클라이언트에서 /WEB-INF/로 시작하는 모든 URL 요청에 대해 자동으로 403 Forbidden 응답을 반환하게됩니다.```java example// ❌ 직접 접근 불가능 - 403 Forbidden 응답// http://localhost:8080/myapp/WEB-INF/web.xml// http://localhost:8080/myapp/WEB-INF/classes/MyServlet.class// ✅ 서버 내부에서만 접근 가능RequestDispatcher dispatcher = request.getRequestDispatcher(\"/WEB-INF/views/user.jsp\");dispatcher.forward(request, response);```#### WEB-INF 내부 구조- web.xml : 웹 애플리케이션의 전체 설정을 담당하는 핵심 파일입니다.- classes/ 디렉토리  - 컴파일된 Java 클래스 파일들이 패키지 구조에 따라 저장  - 서블릿, 필터, 리스너, 비즈니스 로직 클래스들  - properties, xml 등의 설정 파일들- lib/ 디렉토리  - 애플리케이션에서 사용하는 외부 라이브러리 JAR 파일들  - 서버 공통 라이브러리와 구분되는 애플리케이션 전용 라이브러리- views/ 디렉토리 : JSP 뷰 파일들을 보호하기 위해 생성하는 디렉토리로 MVC 패턴에서 직접 접근을 차단하고 컨트롤러를 통해서만 접근간 패턴을 위해 사용"
  }
]