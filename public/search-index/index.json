[
  {
    "metadata": {
      "title": "TypeScript 디자인 패턴 완벽 가이드: 싱글톤부터 옵저버까지",
      "slug": "typescript-design-patterns",
      "thumbnail": "/mdx-images/typescript/design-patterns.jpg",
      "description": "TypeScript에서 구현하는 디자인 패턴들을 알아봅니다.  싱글톤, 팩토리, 옵저버, 전략 패턴 등 실전에서 자주 사용되는  디자인 패턴들을 TypeScript의 타입 시스템과 함께 구현해보세요.\n",
      "category": "TypeScript",
      "tags": [
        "TypeScript",
        "Design Patterns",
        "Architecture",
        "Best Practices"
      ],
      "published": "2025-01-30"
    },
    "content": "## 싱글톤 패턴 (Singleton Pattern)싱글톤 패턴은 클래스의 인스턴스가 하나만 생성되도록 보장하는 패턴입니다.```typescriptclass DatabaseConnection {  private static instance: DatabaseConnection | null = null;  private connectionString: string;  private constructor(connectionString: string) {    this.connectionString = connectionString;  }  public static getInstance(connectionString?: string): DatabaseConnection {    if (!DatabaseConnection.instance) {      if (!connectionString) {        throw new Error(          \"첫 번째 인스턴스 생성 시 connectionString이 필요합니다.\",        );      }      DatabaseConnection.instance = new DatabaseConnection(connectionString);    }    return DatabaseConnection.instance;  }  public connect(): void {    console.log(`데이터베이스에 연결 중: ${this.connectionString}`);  }  public disconnect(): void {    console.log(\"데이터베이스 연결 해제\");  }}// 사용 예시const db1 = DatabaseConnection.getInstance(\"postgresql://localhost:5432/mydb\");const db2 = DatabaseConnection.getInstance(); // 같은 인스턴스 반환console.log(db1 === db2); // true```## 팩토리 패턴 (Factory Pattern)팩토리 패턴은 객체 생성 로직을 캡슐화하여 유연성을 높이는 패턴입니다.```typescript// 제품 인터페이스interface Vehicle {  start(): void;  stop(): void;  getInfo(): string;}// 구체적인 제품들class Car implements Vehicle {  private model: string;  constructor(model: string) {    this.model = model;  }  start(): void {    console.log(`${this.model} 자동차가 시동을 겁니다.`);  }  stop(): void {    console.log(`${this.model} 자동차가 정지합니다.`);  }  getInfo(): string {    return `자동차 모델: ${this.model}`;  }}class Motorcycle implements Vehicle {  private brand: string;  constructor(brand: string) {    this.brand = brand;  }  start(): void {    console.log(`${this.brand} 오토바이가 시동을 겁니다.`);  }  stop(): void {    console.log(`${this.brand} 오토바이가 정지합니다.`);  }  getInfo(): string {    return `오토바이 브랜드: ${this.brand}`;  }}// 팩토리 클래스class VehicleFactory {  public static createVehicle(    type: \"car\" | \"motorcycle\",    model: string,  ): Vehicle {    switch (type) {      case \"car\":        return new Car(model);      case \"motorcycle\":        return new Motorcycle(model);      default:        throw new Error(`지원하지 않는 차량 타입: ${type}`);    }  }}// 사용 예시const car = VehicleFactory.createVehicle(\"car\", \"Tesla Model 3\");const motorcycle = VehicleFactory.createVehicle(\"motorcycle\", \"Honda\");car.start();motorcycle.start();```## 옵저버 패턴 (Observer Pattern)옵저버 패턴은 객체 간의 일대다 의존성을 정의하여 한 객체의 상태가 변경될 때 모든 의존자들이 자동으로 알림을 받는 패턴입니다.```typescript// 옵저버 인터페이스interface Observer {  update(data: any): void;}// 주제 인터페이스interface Subject {  attach(observer: Observer): void;  detach(observer: Observer): void;  notify(): void;}// 구체적인 주제 클래스class NewsAgency implements Subject {  private observers: Observer[] = [];  private news: string = \"\";  attach(observer: Observer): void {    const isExist = this.observers.includes(observer);    if (isExist) {      return console.log(\"이미 구독 중인 옵저버입니다.\");    }    this.observers.push(observer);    console.log(\"옵저버가 구독되었습니다.\");  }  detach(observer: Observer): void {    const observerIndex = this.observers.indexOf(observer);    if (observerIndex === -1) {      return console.log(\"구독하지 않은 옵저버입니다.\");    }    this.observers.splice(observerIndex, 1);    console.log(\"옵저버 구독이 해제되었습니다.\");  }  notify(): void {    console.log(\"모든 옵저버에게 뉴스를 전송합니다.\");    for (const observer of this.observers) {      observer.update(this.news);    }  }  setNews(news: string): void {    this.news = news;    this.notify();  }}// 구체적인 옵저버 클래스들class NewsChannel implements Observer {  private name: string;  constructor(name: string) {    this.name = name;  }  update(news: string): void {    console.log(`${this.name} 채널이 뉴스를 받았습니다: ${news}`);  }}// 사용 예시const newsAgency = new NewsAgency();const channel1 = new NewsChannel(\"CNN\");const channel2 = new NewsChannel(\"BBC\");newsAgency.attach(channel1);newsAgency.attach(channel2);newsAgency.setNews(\"중요한 뉴스가 발생했습니다!\");```## 전략 패턴 (Strategy Pattern)전략 패턴은 알고리즘을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 패턴입니다.```typescript// 전략 인터페이스interface PaymentStrategy {  pay(amount: number): void;}// 구체적인 전략들class CreditCardPayment implements PaymentStrategy {  private cardNumber: string;  private cvv: string;  constructor(cardNumber: string, cvv: string) {    this.cardNumber = cardNumber;    this.cvv = cvv;  }  pay(amount: number): void {    console.log(      `${amount}원을 신용카드로 결제합니다. 카드번호: ${this.cardNumber}`,    );  }}class PayPalPayment implements PaymentStrategy {  private email: string;  constructor(email: string) {    this.email = email;  }  pay(amount: number): void {    console.log(`${amount}원을 PayPal로 결제합니다. 이메일: ${this.email}`);  }}class CashPayment implements PaymentStrategy {  pay(amount: number): void {    console.log(`${amount}원을 현금으로 결제합니다.`);  }}// 컨텍스트 클래스class ShoppingCart {  private paymentStrategy: PaymentStrategy | null = null;  setPaymentStrategy(strategy: PaymentStrategy): void {    this.paymentStrategy = strategy;  }  checkout(amount: number): void {    if (!this.paymentStrategy) {      throw new Error(\"결제 방법을 선택해주세요.\");    }    this.paymentStrategy.pay(amount);  }}// 사용 예시const cart = new ShoppingCart();// 신용카드로 결제cart.setPaymentStrategy(new CreditCardPayment(\"1234-5678-9012-3456\", \"123\"));cart.checkout(50000);// PayPal로 결제cart.setPaymentStrategy(new PayPalPayment(\"user@example.com\"));cart.checkout(30000);// 현금으로 결제cart.setPaymentStrategy(new CashPayment());cart.checkout(15000);```## 마무리TypeScript의 타입 시스템을 활용한 디자인 패턴 구현은 코드의 안전성과 유지보수성을 크게 향상시킵니다. 이 글에서 소개한 패턴들을 실전 프로젝트에 적용하여 더 견고하고 확장 가능한 코드를 작성해보세요. 다음 글에서는 더 고급 디자인 패턴과 실전 활용 사례에 대해 알아보겠습니다."
  },
  {
    "metadata": {
      "title": "TypeScript 고급 패턴 완벽 가이드: 제네릭, 유니온 타입, 조건부 타입까지",
      "slug": "typescript-advanced-patterns",
      "thumbnail": "/mdx-images/typescript/advanced-patterns.png",
      "description": "TypeScript의 고급 기능들을 활용한 실전 패턴들을 알아봅니다.  제네릭, 유니온 타입, 조건부 타입, 매핑 타입 등 복잡한 타입 시스템을  마스터하여 더 안전하고 유연한 코드를 작성해보세요.\n",
      "category": "TypeScript",
      "tags": ["TypeScript", "Advanced", "Type System", "Generics"],
      "published": "2025-01-25"
    },
    "content": "TypeScript의 강력한 타입 시스템을 활용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 이 글에서는 실전에서 유용한 고급 TypeScript 패턴들을 알아보겠습니다.## 제네릭을 활용한 재사용 가능한 타입제네릭은 타입을 매개변수화하여 다양한 타입에서 재사용할 수 있게 해줍니다.```typescript// 기본적인 제네릭 함수function identity<T>(arg: T): T {  return arg;}// 제네릭 인터페이스interface ApiResponse<T> {  data: T;  status: number;  message: string;}// 제네릭 클래스class DataContainer<T> {  private data: T[] = [];  add(item: T): void {    this.data.push(item);  }  get(index: number): T | undefined {    return this.data[index];  }  getAll(): T[] {    return [...this.data];  }}// 사용 예시const numberContainer = new DataContainer<number>();numberContainer.add(1);numberContainer.add(2);const stringContainer = new DataContainer<string>();stringContainer.add(\"hello\");stringContainer.add(\"world\");```## 유니온 타입과 리터럴 타입유니온 타입을 활용하여 더 정확한 타입 정의를 만들 수 있습니다.```typescript// 리터럴 타입과 유니온 타입type Status = \"loading\" | \"success\" | \"error\";type HttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";// 유니온 타입을 활용한 함수 오버로딩function processData(data: string): string;function processData(data: number): number;function processData(data: boolean): boolean;function processData(  data: string | number | boolean,): string | number | boolean {  if (typeof data === \"string\") {    return data.toUpperCase();  } else if (typeof data === \"number\") {    return data * 2;  } else {    return !data;  }}// 유니온 타입을 활용한 상태 관리interface LoadingState {  status: \"loading\";}interface SuccessState<T> {  status: \"success\";  data: T;}interface ErrorState {  status: \"error\";  error: string;}type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;function handleAsyncState<T>(state: AsyncState<T>): string {  switch (state.status) {    case \"loading\":      return \"로딩 중...\";    case \"success\":      return `데이터: ${JSON.stringify(state.data)}`;    case \"error\":      return `에러: ${state.error}`;  }}```## 조건부 타입과 매핑 타입조건부 타입을 사용하여 타입을 동적으로 변환할 수 있습니다.```typescript// 조건부 타입type NonNullable<T> = T extends null | undefined ? never : T;type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;// 매핑 타입type Partial<T> = {  [P in keyof T]?: T[P];};type Required<T> = {  [P in keyof T]-?: T[P];};type Readonly<T> = {  readonly [P in keyof T]: T[P];};// 실전 예시: API 응답 타입 변환interface User {  id: number;  name: string;  email: string;  age: number;}// 선택적 필드로 변환type PartialUser = Partial<User>;// { id?: number; name?: string; email?: string; age?: number; }// 읽기 전용으로 변환type ReadonlyUser = Readonly<User>;// { readonly id: number; readonly name: string; readonly email: string; readonly age: number; }// 특정 필드만 선택type PickUser = Pick<User, \"name\" | \"email\">;// { name: string; email: string; }// 특정 필드 제외type OmitUser = Omit<User, \"id\">;// { name: string; email: string; age: number; }```## 고급 유틸리티 타입복잡한 타입 변환을 위한 고급 유틴리티 타입들을 만들어보겠습니다.```typescript// 함수의 매개변수 타입 추출type Parameters<T> = T extends (...args: infer P) => any ? P : never;// 함수의 반환 타입 추출type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;// 프로미스의 타입 추출type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;// 중첩된 프로미스 타입 추출type DeepUnwrapPromise<T> =  T extends Promise<infer U> ? DeepUnwrapPromise<U> : T;// 객체의 모든 프로퍼티를 함수로 변환type Functionify<T> = {  [P in keyof T]: T[P] extends Function ? T[P] : () => T[P];};// 실전 예시interface Config {  apiUrl: string;  timeout: number;  retries: number;}type ConfigFunctions = Functionify<Config>;// {//   apiUrl: () => string;//   timeout: () => number;//   retries: () => number;// }// 조건부 타입을 활용한 타입 가드type IsString<T> = T extends string ? true : false;type IsNumber<T> = T extends number ? true : false;// 타입 안전한 이벤트 핸들러type EventHandler<T extends Event> = (event: T) => void;interface CustomEvent {  type: \"custom\";  data: any;}type CustomEventHandler = EventHandler<CustomEvent>;```## 마무리TypeScript의 고급 패턴들을 활용하면 타입 안전성을 높이면서도 유연한 코드를 작성할 수 있습니다. 이 글에서 소개한 패턴들을 실전 프로젝트에 적용하여 더 견고한 타입 시스템을 구축해보세요. 다음 글에서는 더 복잡한 타입 패턴과 실전 활용 사례에 대해 알아보겠습니다."
  },
  {
    "metadata": {
      "title": "들어가기에 앞서",
      "slug": "rust-foreword",
      "thumbnail": "/mdx-images/rust/rust-img.png",
      "description": "러스트 프로그래밍 언어는 역량 강화 (empowerment)에 근간을 두고 있습니다.  여러분이 지금 어떤 종류의 코드를 작성하고 있건 간에, 러스트는 여러분에게  더 멀리 나아가고, 더 다양한 분야에서 더 자신감 있게 프로그래밍할 역량을 줍니다.\n",
      "category": "Rust",
      "tags": ["Language", "Rust"],
      "published": "2025-08-24"
    },
    "content": "~~취소선~~콕 집어서 말할 순 없지만, 러스트 프로그래밍 언어는 역량 강화 (empowerment)에 근간을 두고 있습니다. 여러분이 지금 어떤 종류의 코드를 작성하고 있건 간에, 러스트는 여러분에게 더 멀리 나아가고, 더 다양한 분야에서 더 자신감 있게 프로그래밍할 역량을 줍니다.## 시스템 프로그래밍의 도전예를 들어 메모리 관리, 데이터 표현, 동시성 등 저수준의 정보를 다루는 '시스템 수준' 프로그래밍을 생각해 봅시다. 예로부터 이 분야는 악명 높은 함정을 피하고자 수년 동안 관련 지식을 쌓아온 소수 정예만이 다가갈 수 있는 난해한 영역으로 여겨져 왔습니다. 그리고 이런 사람들마저도 코드에 취약점 공격, 충돌이나 손상의 위험이 없도록 심혈을 기울여 작업해야 합니다.### 러스트의 해결책러스트는 이런 오래된 문제를 제거하는 동시에 여러분에게 친숙하고 세련된 도구를 제공함으로써 이 장벽을 부숩니다. 저수준 제어에 '살짝만 발을 담글' 필요가 있는 프로그래머는 여느 때처럼 충돌이나 보안 허점의 위험을 떠맡을 필요도, 까다로운 툴체인의 세세한 특징을 학습할 필요도 없이 러스트로 자신의 목적을 달성할 수 있습니다. 게다가 이 언어는 속도와 메모리 사용량 측면에서 효율적인 신뢰할 수 있는 코드로 자연스럽게 인도하도록 설계되었습니다.## 기존 프로그래머를 위한 러스트이전부터 저수준 코드를 작성하던 프로그래머는 러스트를 사용하여 야망을 키울 수 있습니다. 예를 들면, 러스트에서 병렬화를 도입하는 것은 비교적 위험도가 낮은 작업입니다. 컴파일러가 고전적인 실수를 잡아주거든요. 또한 실수로 충돌이나 취약점을 발생시키지 않을 것이라는 확신을 가지고 코드에 대한 더 공격적인 최적화를 수행할 수 있습니다.### 러스트의 다양한 활용러스트는 저수준 시스템 프로그래밍에만 국한되지 않습니다. CLI 앱, 웹 서버 등 수많은 종류의 코드를 편하게 작성할 수 있을 정도로 표현력이 풍부하고 개발자 친화적으로 설계되어 있습니다. 이 책을 읽다 보면 CLI 앱과 웹 서버 두 경우에 대한 간단한 예제가 나올 것입니다. 러스트로 작업하면 한 분야에서 구축한 기술을 다른 분야에도 써먹을 수 있습니다. 웹 앱을 작성하면서 러스트를 배운 다음, 같은 기술을 라즈베리 파이를 대상으로 적용해 볼 수 있지요.## 마무리이 책은 사용자의 역량을 강화할 러스트의 잠재력을 완전히 담아내었습니다. 친근하고 접근하기 쉬운 텍스트로 러스트에 대한 지식뿐만 아니라 프로그래머로서의 능력과 자신감도 향상시킬 수 있도록 노력했습니다. 그럼, 바로 시작해서 배울 준비를 해보죠. 러스트 커뮤니티에 오신 것을 환영합니다!— Nicholas Matsakis, Aaron Turon"
  },
  {
    "metadata": {
      "title": "JavaScript 함수형 프로그래밍 완벽 가이드: 순수함수부터 모나드까지",
      "slug": "javascript-functional-programming",
      "thumbnail": "/mdx-images/javascript/javascript-functional.webp",
      "description": "JavaScript에서 함수형 프로그래밍을 구현하는 방법을 알아봅니다.  순수함수, 고차함수, 커링, 합성, 모나드 등 함수형 프로그래밍의  핵심 개념들을 실전 예제와 함께 학습해보세요.\n",
      "category": "JavaScript",
      "tags": [
        "JavaScript",
        "Functional Programming",
        "Pure Functions",
        "Monads"
      ],
      "published": "2025-02-10"
    },
    "content": "## 순수함수 (Pure Functions)순수함수는 같은 입력에 대해 항상 같은 출력을 반환하고, 부수효과가 없는 함수입니다.~~이전에는 명령형 프로그래밍이 주로 사용되었지만~~, 함수형 프로그래밍이 더 안전하고 예측 가능한 코드를 작성할 수 있게 해줍니다.```javascript util.js// 하이라이트된 라인 예시const add = (a, b) => a + b;const multiply = (a, b) => a * b;``````javascript// 순수함수 예시const add = (a, b) => a + b;const multiply = (a, b) => a * b;const square = (x) => x * x;// 순수하지 않은 함수 (부수효과 있음)let total = 0;const addToTotal = (amount) => {  total += amount; // 외부 상태 변경  return total;};// 순수함수로 개선const addToTotalPure = (currentTotal, amount) => currentTotal + amount;// 배열 조작에서 순수함수 사용const numbers = [1, 2, 3, 4, 5];// 순수하지 않은 방법 (원본 배열 변경)const doubleNumbersImpure = (arr) => {  for (let i = 0; i < arr.length; i++) {    arr[i] = arr[i] * 2;  }  return arr;};// 순수함수 방법 (새 배열 반환)const doubleNumbersPure = (arr) => arr.map((x) => x * 2);// 사용 예시const doubled = doubleNumbersPure(numbers);console.log(numbers); // [1, 2, 3, 4, 5] (원본 유지)console.log(doubled); // [2, 4, 6, 8, 10] (새 배열)```## 고차함수 (Higher-Order Functions)고차함수는 함수를 매개변수로 받거나 함수를 반환하는 함수입니다.```javascript// 함수를 매개변수로 받는 고차함수const withLogging = (fn, name) => {  return (...args) => {    console.log(`함수 ${name} 호출됨:`, args);    const result = fn(...args);    console.log(`함수 ${name} 결과:`, result);    return result;  };};// 사용 예시const add = (a, b) => a + b;const addWithLogging = withLogging(add, \"add\");addWithLogging(3, 5); // 로그와 함께 실행// 함수를 반환하는 고차함수const createMultiplier = (factor) => {  return (number) => number * factor;};const double = createMultiplier(2);const triple = createMultiplier(3);console.log(double(5)); // 10console.log(triple(5)); // 15// 배열 고차함수들const users = [  { id: 1, name: \"Alice\", age: 25, active: true },  { id: 2, name: \"Bob\", age: 30, active: false },  { id: 3, name: \"Charlie\", age: 35, active: true },  { id: 4, name: \"Diana\", age: 28, active: true },];// filter, map, reduce 조합const activeUserNames = users  .filter((user) => user.active)  .map((user) => user.name)  .reduce((acc, name) => acc + \", \" + name, \"\");console.log(activeUserNames); // \"Alice, Charlie, Diana\"```## 커링 (Currying)커링은 여러 매개변수를 받는 함수를 하나씩 받는 함수들의 체인으로 변환하는 기법입니다.```javascript// 기본 커링 함수const curry = (fn) => {  return function curried(...args) {    if (args.length >= fn.length) {      return fn.apply(this, args);    }    return function (...moreArgs) {      return curried.apply(this, args.concat(moreArgs));    };  };};// 사용 예시const add = (a, b, c) => a + b + c;const curriedAdd = curry(add);console.log(curriedAdd(1)(2)(3)); // 6console.log(curriedAdd(1, 2)(3)); // 6console.log(curriedAdd(1)(2, 3)); // 6// 실용적인 커링 예시const multiply = (a) => (b) => a * b;const double = multiply(2);const triple = multiply(3);console.log(double(5)); // 10console.log(triple(5)); // 15// 배열 처리에서 커링 활용const filter = (predicate) => (array) => array.filter(predicate);const map = (fn) => (array) => array.map(fn);const reduce = (fn, initial) => (array) => array.reduce(fn, initial);const isActive = (user) => user.active;const getName = (user) => user.name;const joinNames = (acc, name) => acc + \", \" + name;const getActiveUserNames = pipe(  filter(isActive),  map(getName),  reduce(joinNames, \"\"));console.log(getActiveUserNames(users)); // \"Alice, Charlie, Diana\"```## 함수 합성 (Function Composition)함수 합성은 여러 함수를 조합하여 새로운 함수를 만드는 기법입니다.```javascript// 기본 합성 함수const compose =  (...fns) =>  (x) =>    fns.reduceRight((acc, fn) => fn(acc), x);const pipe =  (...fns) =>  (x) =>    fns.reduce((acc, fn) => fn(acc), x);// 사용 예시const addOne = (x) => x + 1;const double = (x) => x * 2;const square = (x) => x * x;// compose: 오른쪽에서 왼쪽으로 실행const composed = compose(square, double, addOne);console.log(composed(3)); // ((3 + 1) * 2)² = 64// pipe: 왼쪽에서 오른쪽으로 실행const piped = pipe(addOne, double, square);console.log(piped(3)); // ((3 + 1) * 2)² = 64// 실전 예시: 사용자 데이터 처리const users = [  { name: \"Alice\", age: 25, score: 85 },  { name: \"Bob\", age: 30, score: 92 },  { name: \"Charlie\", age: 35, score: 78 },  { name: \"Diana\", age: 28, score: 95 },];const filterByAge = (minAge) => (users) =>  users.filter((user) => user.age >= minAge);const sortByScore = (users) => users.sort((a, b) => b.score - a.score);const takeTop = (n) => (users) => users.slice(0, n);const getNames = (users) => users.map((user) => user.name);// 파이프라인 구성const getTopYoungUsers = pipe(  filterByAge(25),  sortByScore,  takeTop(2),  getNames);console.log(getTopYoungUsers(users)); // ['Diana', 'Bob']```## 모나드 (Monads)모나드는 부수효과를 안전하게 처리할 수 있게 해주는 구조입니다.```javascript// Maybe 모나드class Maybe {  constructor(value) {    this.value = value;  }  static of(value) {    return new Maybe(value);  }  map(fn) {    return this.value === null || this.value === undefined      ? Maybe.of(null)      : Maybe.of(fn(this.value));  }  flatMap(fn) {    return this.value === null || this.value === undefined      ? Maybe.of(null)      : fn(this.value);  }  getOrElse(defaultValue) {    return this.value === null || this.value === undefined      ? defaultValue      : this.value;  }}// 사용 예시const user = {  name: \"John\",  address: {    street: \"123 Main St\",    city: \"Seoul\",  },};const getUserCity = (user) =>  Maybe.of(user)    .map((u) => u.address)    .map((addr) => addr.city)    .getOrElse(\"Unknown\");console.log(getUserCity(user)); // 'Seoul'console.log(getUserCity({})); // 'Unknown'// Either 모나드class Either {  constructor(left, right) {    this.left = left;    this.right = right;  }  static left(value) {    return new Either(value, null);  }  static right(value) {    return new Either(null, value);  }  map(fn) {    return this.right !== null      ? Either.right(fn(this.right))      : Either.left(this.left);  }  flatMap(fn) {    return this.right !== null ? fn(this.right) : Either.left(this.left);  }  fold(leftFn, rightFn) {    return this.right !== null ? rightFn(this.right) : leftFn(this.left);  }}// 사용 예시const divide = (a, b) => {  return b === 0 ? Either.left(\"0으로 나눌 수 없습니다\") : Either.right(a / b);};const result = divide(10, 2)  .map((x) => x * 2)  .fold(    (error) => `에러: ${error}`,    (value) => `결과: ${value}`  );console.log(result); // '결과: 10'```## 다양한 언어 예시### TypeScript 예시```typescriptinterface User {  id: number;  name: string;  email: string;  isActive: boolean;}type UserStatus = \"active\" | \"inactive\" | \"pending\";class UserService {  private users: User[] = [];  async getUserById(id: number): Promise<User | null> {    return this.users.find((user) => user.id === id) || null;  }  async updateUserStatus(id: number, status: UserStatus): Promise<User> {    const user = await this.getUserById(id);    if (!user) {      throw new Error(`User with id ${id} not found`);    }    return { ...user, isActive: status === \"active\" };  }}```### CSS 예시```css.user-card {  display: flex;  flex-direction: column;  padding: 1rem;  border-radius: 8px;  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);  transition: transform 0.2s ease-in-out;}.user-card:hover {  transform: translateY(-2px);  box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);}.user-avatar {  width: 64px;  height: 64px;  border-radius: 50%;  object-fit: cover;  border: 3px solid rgba(255, 255, 255, 0.3);}.user-info {  margin-top: 1rem;  color: white;}.user-name {  font-size: 1.25rem;  font-weight: 600;  margin-bottom: 0.5rem;}.user-email {  font-size: 0.875rem;  opacity: 0.9;}```### Rust 예시```rustuse std::collections::HashMap;#[derive(Debug, Clone)]struct User {    id: u32,    name: String,    email: String,    is_active: bool,}impl User {    fn new(id: u32, name: String, email: String) -> Self {        User {            id,            name,            email,            is_active: true,        }    }    fn deactivate(&mut self) {        self.is_active = false;    }    fn activate(&mut self) {        self.is_active = true;    }}fn main() {    let mut users: HashMap<u32, User> = HashMap::new();    let user1 = User::new(1, \"Alice\".to_string(), \"alice@example.com\".to_string());    let user2 = User::new(2, \"Bob\".to_string(), \"bob@example.com\".to_string());    users.insert(user1.id, user1);    users.insert(user2.id, user2);    if let Some(user) = users.get_mut(&1) {        user.deactivate();        println!(\"User deactivated: {:?}\", user);    }}```### JSX 예시```jsximport React, { useState, useEffect } from \"react\";const UserCard = ({ user, onStatusChange }) => {  const [isLoading, setIsLoading] = useState(false);  const [status, setStatus] = useState(user.isActive ? \"active\" : \"inactive\");  const handleStatusToggle = async () => {    setIsLoading(true);    try {      const newStatus = status === \"active\" ? \"inactive\" : \"active\";      await onStatusChange(user.id, newStatus);      setStatus(newStatus);    } catch (error) {      console.error(\"Failed to update status:\", error);    } finally {      setIsLoading(false);    }  };  return (    <div className=\"user-card\">      <img src={user.avatar} alt={user.name} className=\"user-avatar\" />      <div className=\"user-info\">        <h3 className=\"user-name\">{user.name}</h3>        <p className=\"user-email\">{user.email}</p>        <button          onClick={handleStatusToggle}          disabled={isLoading}          className={`status-button ${status}`}        >          {isLoading ? \"Updating...\" : status}        </button>      </div>    </div>  );};export default UserCard;```## 마무리함수형 프로그래밍은 JavaScript에서 더 안전하고 예측 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서 소개한 개념들을 실전 프로젝트에 적용하여 더 견고하고 유지보수하기 쉬운 코드를 작성해보세요. 다음 글에서는 더 고급 함수형 프로그래밍 패턴과 실전 활용 사례에 대해 알아보겠습니다."
  },
  {
    "metadata": {
      "title": "React 성능 최적화 완벽 가이드: 메모이제이션부터 코드 스플리팅까지",
      "slug": "react-performance-optimization",
      "thumbnail": "/mdx-images/react/performance.png",
      "description": "React 애플리케이션의 성능을 최적화하는 다양한 기법들을 알아봅니다.  React.memo, useMemo, useCallback, 코드 스플리팅 등 실전에서 바로  적용할 수 있는 최적화 방법들을 소개합니다.\n",
      "category": "React.js",
      "tags": ["React", "Performance", "Optimization", "Frontend"],
      "published": "2025-01-20"
    },
    "content": "React 애플리케이션의 성능을 향상시키는 것은 사용자 경험에 직접적인 영향을 미칩니다. 이 글에서는 React에서 사용할 수 있는 다양한 성능 최적화 기법들을 알아보겠습니다.## React.memo로 불필요한 리렌더링 방지React.memo는 props가 변경되지 않았을 때 컴포넌트의 리렌더링을 방지합니다.```jsximport React from \"react\";const ExpensiveComponent = React.memo(({ data, onUpdate }) => {  console.log(\"ExpensiveComponent 렌더링\");  return (    <div>      <h3>복잡한 계산 결과</h3>      <p>{data.map((item) => item.value).join(\", \")}</p>      <button onClick={onUpdate}>업데이트</button>    </div>  );});function ParentComponent() {  const [count, setCount] = React.useState(0);  const [data, setData] = React.useState([    { id: 1, value: \"A\" },    { id: 2, value: \"B\" },  ]);  const handleUpdate = React.useCallback(() => {    setData((prev) => [...prev, { id: Date.now(), value: \"C\" }]);  }, []);  return (    <div>      <p>카운트: {count}</p>      <button onClick={() => setCount(count + 1)}>카운트 증가</button>      <ExpensiveComponent data={data} onUpdate={handleUpdate} />    </div>  );}```## useMemo로 값 메모이제이션useMemo는 계산 비용이 큰 값을 메모이제이션하여 성능을 향상시킵니다.```jsximport React, { useMemo } from \"react\";function DataVisualization({ data, filter }) {  const processedData = useMemo(() => {    console.log(\"데이터 처리 중...\");    return data      .filter((item) => item.category === filter)      .map((item) => ({        ...item,        processedValue: item.value * 2 + Math.sqrt(item.value),      }))      .sort((a, b) => b.processedValue - a.processedValue);  }, [data, filter]);  return (    <div>      <h3>처리된 데이터</h3>      <ul>        {processedData.map((item) => (          <li key={item.id}>            {item.name}: {item.processedValue.toFixed(2)}          </li>        ))}      </ul>    </div>  );}```## useCallback으로 함수 메모이제이션useCallback은 함수를 메모이제이션하여 자식 컴포넌트의 불필요한 리렌더링을 방지합니다.```jsximport React, { useCallback, useState } from \"react\";function TodoList() {  const [todos, setTodos] = useState([]);  const [inputValue, setInputValue] = useState(\"\");  const addTodo = useCallback((text) => {    setTodos((prev) => [      ...prev,      {        id: Date.now(),        text,        completed: false,      },    ]);  }, []);  const toggleTodo = useCallback((id) => {    setTodos((prev) =>      prev.map((todo) =>        todo.id === id ? { ...todo, completed: !todo.completed } : todo,      ),    );  }, []);  const removeTodo = useCallback((id) => {    setTodos((prev) => prev.filter((todo) => todo.id !== id));  }, []);  const handleSubmit = (e) => {    e.preventDefault();    if (inputValue.trim()) {      addTodo(inputValue.trim());      setInputValue(\"\");    }  };  return (    <div>      <form onSubmit={handleSubmit}>        <input          value={inputValue}          onChange={(e) => setInputValue(e.target.value)}          placeholder=\"할 일을 입력하세요\"        />        <button type=\"submit\">추가</button>      </form>      <TodoItems todos={todos} onToggle={toggleTodo} onRemove={removeTodo} />    </div>  );}const TodoItems = React.memo(({ todos, onToggle, onRemove }) => {  return (    <ul>      {todos.map((todo) => (        <li key={todo.id}>          <input            type=\"checkbox\"            checked={todo.completed}            onChange={() => onToggle(todo.id)}          />          <span            style={{ textDecoration: todo.completed ? \"line-through\" : \"none\" }}          >            {todo.text}          </span>          <button onClick={() => onRemove(todo.id)}>삭제</button>        </li>      ))}    </ul>  );});```## 코드 스플리팅으로 번들 크기 최적화React.lazy와 Suspense를 사용하여 코드 스플리팅을 구현할 수 있습니다.```jsximport React, { Suspense, lazy } from \"react\";// 지연 로딩할 컴포넌트들const Dashboard = lazy(() => import(\"./Dashboard\"));const Settings = lazy(() => import(\"./Settings\"));const Profile = lazy(() => import(\"./Profile\"));function App() {  const [currentPage, setCurrentPage] = React.useState(\"dashboard\");  const renderPage = () => {    switch (currentPage) {      case \"dashboard\":        return <Dashboard />;      case \"settings\":        return <Settings />;      case \"profile\":        return <Profile />;      default:        return <Dashboard />;    }  };  return (    <div>      <nav>        <button onClick={() => setCurrentPage(\"dashboard\")}>대시보드</button>        <button onClick={() => setCurrentPage(\"settings\")}>설정</button>        <button onClick={() => setCurrentPage(\"profile\")}>프로필</button>      </nav>      <Suspense fallback={<div>로딩 중...</div>}>{renderPage()}</Suspense>    </div>  );}```## 마무리React 성능 최적화는 애플리케이션의 사용자 경험을 크게 향상시킬 수 있습니다. 이 글에서 소개한 기법들을 적절히 활용하여 더 빠르고 반응성 좋은 React 애플리케이션을 만들어보세요. 다음 글에서는 더 고급 최적화 기법과 성능 측정 방법에 대해 알아보겠습니다."
  },
  {
    "metadata": {
      "title": "React Hooks 완벽 가이드: useState부터 커스텀 훅까지",
      "slug": "react-hooks-guide",
      "thumbnail": "/mdx-images/react/react-hooks.png",
      "description": "React Hooks의 모든 것을 알아보는 완벽한 가이드입니다.  useState, useEffect, useContext 등 기본 훅부터 커스텀 훅 작성까지  실전 예제와 함께 학습해보세요.\n",
      "category": "React.js",
      "tags": ["React", "Hooks", "Frontend", "JavaScript"],
      "published": "2025-01-15"
    },
    "content": "## useState: 상태 관리의 시작useState는 컴포넌트에서 상태를 관리하는 가장 기본적인 Hook입니다.```jsximport React, { useState } from \"react\";function Counter() {  const [count, setCount] = useState(0);  return (    <div>      <p>현재 카운트: {count}</p>      <button onClick={() => setCount(count + 1)}>증가</button>    </div>  );}```## useEffect: 사이드 이펙트 처리useEffect는 컴포넌트의 생명주기와 관련된 사이드 이펙트를 처리합니다.```jsximport React, { useState, useEffect } from \"react\";function UserProfile({ userId }) {  const [user, setUser] = useState(null);  const [loading, setLoading] = useState(true);  useEffect(() => {    const fetchUser = async () => {      try {        const response = await fetch(`/api/users/${userId}`);        const userData = await response.json();        setUser(userData);      } catch (error) {        console.error(\"사용자 정보 로딩 실패:\", error);      } finally {        setLoading(false);      }    };    fetchUser();  }, [userId]);  if (loading) return <div>로딩 중...</div>;  if (!user) return <div>사용자를 찾을 수 없습니다.</div>;  return (    <div>      <h2>{user.name}</h2>      <p>{user.email}</p>    </div>  );}```## 커스텀 훅 만들기자주 사용하는 로직을 커스텀 훅으로 만들어 재사용할 수 있습니다.```jsximport { useState, useEffect } from \"react\";function useLocalStorage(key, initialValue) {  const [storedValue, setStoredValue] = useState(() => {    try {      const item = window.localStorage.getItem(key);      return item ? JSON.parse(item) : initialValue;    } catch (error) {      console.error(error);      return initialValue;    }  });  const setValue = (value) => {    try {      const valueToStore =        value instanceof Function ? value(storedValue) : value;      setStoredValue(valueToStore);      window.localStorage.setItem(key, JSON.stringify(valueToStore));    } catch (error) {      console.error(error);    }  };  return [storedValue, setValue];}```## 마무리React Hooks는 함수형 컴포넌트의 강력함을 극대화하는 도구입니다. 이 가이드를 통해 Hooks의 기본 개념을 이해하고, 실전에서 활용할 수 있는 방법을 배웠습니다. 다음 글에서는 더 고급 Hooks 패턴과 최적화 기법에 대해 알아보겠습니다."
  }
]
